%! Author vonesch, wächter,sebrek
%! Date = 11.12.21

% Preamble
\documentclass[11pt]{article}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}


% Packages
\usepackage{amsmath}

\title{Bloom Filter}
\author{Tobias Vonesch, Michelle Wächter, Aleks Sebrek}

% Document
\begin{document}
    \maketitle

    \section{Idee des Bloom-Filters}

    Ein Bloom-Filter ist eine, auf Hashing basierende probabilistische Datenstruktur.
    Er wird in der Regel verwendet, um Elemente zu einer Menge hinzuzuf{\"u}gen und zu pr{\"u}fen, ob ein Element in einer Menge enthalten ist, da er extrem Platzsparend ist.
    Nicht die Elemente selbst werden zu einer Menge hinzugef{\"u}gt, sondern der Hash der Elemente. \\

    Bei der {\"U}berpr{\"u}fung, ob ein Element im Bloom-Filter enthalten ist, ist es m{\"o}glich false positives zu erhalten.
    Entweder stellt man fest, dass ein Element definitiv nicht in der Menge enthalten ist, oder dass es m{\"o}glich ist, dass das Element in der Menge enthalten ist.
    Wenn der Bloom-Filter allerdings sagt, dass das Element nicht in der Datenstruktur enthalten ist, ist es ganz bestimmt nicht darin enthalten.\\

    Ein Bloom-Filter {\"a}hnelt einer Hash-Tabelle, da er eine Hash-Funktion verwendet, um einen Schl{\"u}ssel einem Bucket zuzuordnen.
    Er speichert diesen Schl{\"u}ssel jedoch nicht in diesem Bereich, sondern markiert ihn lediglich als gef{\"u}llt.
    So k{\"o}nnen viele Schl{\"u}ssel demselben gef{\"u}llten Bucket zugeordnet werden, was zu falsch positiven Ergebnissen f{\"u}hrt.

    \subsection{Anforderung Hash-Funktion}
    Die in einem Bloom-Filter verwendeten Hash-Funktionen sollten unabh{\"a}ngig und gleichm{\"a}ssig verteilt sein.
    Sie sollten ausserdem so schnell wie mo{\"o}lich sein (kryptografische Hash-Funktionen wie sha1, sind daher keine gute Wahl).

    \subsection{Vorteile}
    Eines der Hauptvorteile ist, dass Hashfunktionen Simultan berechnet werden k{\"o}nnen.
    Zus{\"a}tzlich k{\"o}nnen alle Anfragen gleichzeitig gestellt werden, solange bis ein neues Element in die Datenbank geschrieben wird.
    Ein weiterer Vorteil ist der geringe Overhead.


    \subsection{Nachteile}
    Ein Nachteil k{\"o}nnte das Debugging des Systems sein in Verbindung mit der Konsistenz bei verteilten Anwendungn.

    \section{Beispiel aus der Praxis}
    Der Webbrowser Google Chrome pflegt einen Bloomfilter mit den Signaturen gef{\"a}hrlicher Webseiten und {\"u}berpr{\"u}ft bei Eingabe einer URL, ob diese in diesem Filter enthalten ist.
    Bei jeder URL-Anfrage, die {\"u}ber Chrome gestellt wird, erfolgt die URL-Validierung {\"u}ber den Google-Server, was zu einer zus{\"a}tzlichen Abh{\"a}ngigkeit von den Google-Servern, zu einer l{\"a}ngeren Netzwerklaufzeit und zu der Anforderung f{\"u}hrt, eine hohe Verf{\"u}gbarkeit zu gew{\"a}hrleisten, um die URLs f{\"u}r alle URLs zu validieren, die von Chrome-Browsern auf der ganzen Welt gesendet werden.

    \section{Fehlerwahrscheinlichkeit}
    In unserem Programm ist es m{\"o}glich eine Fehlerwahrscheinlichkeit P vorzugeben.
    Mithilfe dieses P und der Gr{\"o}sse des Datensatzes werden Filter und Anzahl Hashes berechnet.
    Die Gr{\"o}sse des Filters wird mittels der Folgenden Formel bestimmt:

     \begin{align*}
        m = \frac{n * log(p)}{log(\frac{1}{2^{log(2)}})}
    \end{align*}
    \smallskip
    m = die Gr{\"o}sse des Filters
    \\
    n = die Gr{\"o}sse des Datensatzes
    \\
    \\
    Die Anzahl der Hashes wird mittels folgender Formel bestimmt:

    \begin{align*}
        k = -(log(p) * log(2))
    \end{align*}
    \smallskip
    k = Anzahl der Hash-Funktionen (aber mindestens 1)
    \\
    p = gew{\"u}nschte Probabilit{\"a}t
    \medskip

    \subsection{Test}
    Um auszuwerten wie gut unser Filter funktioniert und wie hoch die effektive FalsePositive Rate ist,
    haben wir einen zweiten, komplett verschiedenen Datensatz mit W{\"o}rtern der Niederl{\"a}ndischen Sprache zusammengesucht.
    So l{\"a}sst sich einfach sagen, dass jedes Positive ein FalsePositive sein muss. Der zweite Datensatz ist {\"u}berdies um einiges
    gr{\"o}sser als der vorgegebene. Um die Effektivit{\"a}t zu messen, teilen wir also einfach die Anzahl FalsePositives durch die Anzahl
    Testw{\"o}rter.

    \begin{align*}
    (\frac{False Positives}{Anzahl Woerter})
    \end{align*}

    \newpage
    \subsection{Resultate}



\end{document}
